<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unikernels in OCaml and network</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-ba81fcc6.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-f346a6d4.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Unikernels in OCaml and network</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><code>mnet</code> is a library that provides the networking foundation for unikernels. It
lets you build services ranging from public-facing web servers to more
specialized tools such as a DNS resolver (to circumvent censorship) or a DNS
blocker (to filter out advertising). In this short book, we will walk through
several practical examples that show what unikernels in OCaml can do.</p>
<h2 id="what-is-a-unikernel"><a class="header" href="#what-is-a-unikernel">What is a unikernel?</a></h2>
<p>A unikernel is a specialized, single-purpose operating system that bundles your
application code with only the OS components it actually needs. Nothing more.
Instead of running your OCaml application on top of a general-purpose OS such
as Linux (which ships with thousands of features you will never use), a
unikernel compiles your code together with only the minimal set of libraries
needed for networking, storage, and memory management.</p>
<p>The result is a single bootable image that runs inside a sandboxed environment.
There is no shell, no unnecessary drivers, and no multi-user support. It is just
your application and the bare minimum required to run it.</p>
<p>In practice, building an OCaml unikernel relies on two key components.
<a href="https://github.com/solo5/solo5">Solo5</a> provides the sandboxed execution environment: it defines a
minimal, stable interface between your unikernel and the underlying host
(whether that host is a hypervisor such as KVM, or a sandboxed Linux process
using <a href="https://en.wikipedia.org/wiki/Seccomp">seccomp</a>). Solo5 handles the low-level details of how your
unikernel boots, accesses network interfaces, and reads from block devices. On
top of Solo5, <a href="https://github.com/robur-coop/mkernel"><code>mkernel</code></a> is a library that lets you write unikernels
in OCaml using the <a href="https://github.com/robur-coop/miou">Miou</a> scheduler. It exposes the devices that Solo5
provides (network interfaces and block storage) and gives you a familiar OCaml
programming model for building your application.</p>
<p>When you compile your OCaml code with <code>mkernel</code>, the build system produces a
standalone image that can be launched using a Solo5 <em>tender</em> (a small host-side
program such as <code>solo5-hvt</code>). The practical benefits are significant: a smaller
attack surface, faster boot times (often measured in milliseconds), a reduced
memory footprint, and simpler deployment, since the entire system is a single
artifact.</p>
<h2 id="the-ecosystem-for-ocaml-unikernels"><a class="header" href="#the-ecosystem-for-ocaml-unikernels">The ecosystem for OCaml unikernels</a></h2>
<p><code>mnet</code> is part of a broader ecosystem of OCaml libraries that <a href="https://robur.coop">our
cooperative</a> maintains for unikernel development. This ecosystem provides
pure OCaml reimplementations of essential components (networking, cryptography,
and more) so that you can build fully self-contained applications without
relying on C bindings or system libraries. Here are some of the libraries we
use throughout this tutorial.</p>
<ol>
<li>At the foundation, <a href="https://github.com/robur-coop/mkernel"><code>mkernel</code></a> provides the runtime, including
hypercalls for network and block devices, clock access, and integration with
the Miou scheduler.</li>
<li>For networking, <a href="https://github.com/robur-coop/utcp"><code>utcp</code></a> is a pure OCaml implementation of the TCP
protocol, used internally by <code>mnet</code>. It originated from a manual extraction
of a <a href="https://hol-theorem-prover.org/">HOL4</a> specification of the TCP state
machine (described in detail in <a href="https://www.cl.cam.ac.uk/~pes20/Netsem/paper3.pdf">this paper</a>).</li>
<li><a href="https://github.com/mirage/ocaml-solo5"><code>ocaml-solo5</code></a> is a variant of the
OCaml compiler that targets Solo5, making cross-compilation possible.</li>
<li>On the cryptography side, <a href="https://github.com/mirage/mirage-crypto"><code>mirage-crypto</code></a> provides our
cryptographic primitives, and some of its operations are derived from
formally verified proofs in Rocq/Coq via the <a href="https://github.com/mit-plv/fiat-crypto">fiat</a> project.</li>
</ol>
<p>We will encounter more of these libraries as we go.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Unikernels require a different build process than standard executables. We are
actively improving the development workflow for <code>mkernel</code>, but it is still
evolving. Everything described in this tutorial is accurate and functional,
but you can expect the process to become smoother over time. To get started,
you will need:</p>
<ul>
<li>OCaml version 5.0.0 or later,</li>
<li>along with OPAM, the OCaml package manager (you can find installation
instructions <a href="https://opam.ocaml.org/doc/Install.html">here</a>).</li>
<li>You will also need <a href="https://github.com/mirage/ocaml-solo5"><code>ocaml-solo5</code></a>, which lets you compile an
OCaml project as a unikernel, as well as the Solo5 tools (<code>solo5-hvt</code> or
<code>solo5-spt</code>) for running unikernels.</li>
<li>Finally, you will need access to a hypervisor such as KVM, BHyve, or VMM.</li>
</ul>
<p>You can install everything you need using these commands:</p>
<pre><code class="language-bash">$ opam switch create 5.4.0
$ eval $(opam env)
$ opam install solo5
$ opam install ocaml-solo5
$ opam install mkernel
$ opam install mnet
</code></pre>
<p>To run a unikernel, you need access to a hypervisor or a sandboxing mechanism.
On Linux, the simplest option is KVM (Kernel-based Virtual Machine). You can
check whether your system supports it by running:</p>
<pre><code class="language-bash">$ ls /dev/kvm
</code></pre>
<p>If this device exists, you are ready to go. You may need to add your user to
the <code>kvm</code> group so that you can access it without root privileges:</p>
<pre><code class="language-bash">$ sudo usermod -aG kvm $USER
</code></pre>
<p>After running this command, log out and log back in for the change to take
effect. Once KVM is available, you can run your unikernel with the <code>solo5-hvt</code>
tender, which uses KVM to execute your image in an isolated virtual
environment.</p>
<h2 id="your-first-unikernel"><a class="header" href="#your-first-unikernel">Your first unikernel</a></h2>
<p>A unikernel is an executable that must be <em>cross-compiled</em>. This means it is
built using the <code>ocaml-solo5</code> compiler rather than the regular host compiler.
Because of this, the build configuration looks slightly different from what you
might be used to:</p>
<pre><code class="language-bash">$ cat &gt;dune&lt;&lt;EOF
(executable
 (name main)
 (modules main)
 (link_flags :standard -cclib "-z solo5-abi=hvt")
 (libraries mkernel)
 (foreign_stubs
  (language c)
  (names manifest)))

(rule
 (targets manifest.c)
 (deps manifest.json)
 (enabled_if
  (= %{context_name} "solo5"))
 (action
  (run solo5-elftool gen-manifest manifest.json manifest.c)))

(rule
 (targets manifest.c)
 (enabled_if
  (= %{context_name} "default"))
 (action
  (write-file manifest.c "")))

(vendored_dirs vendors)
EOF
</code></pre>
<p>To boot as quickly as possible, a unikernel does not perform <em>device
discovery</em>: it never asks the tender which devices are available. Instead, it
contains a <strong>static</strong> list of the devices it requires. This list is written as
a JSON file, which is then compiled into the <code>manifest.c</code> file that becomes
part of your unikernel:</p>
<pre><code class="language-bash">$ cat &gt;manifest.json&lt;&lt;EOF
{"type":"solo5.manifest","version":1,"devices":[]}
EOF
</code></pre>
<p>To cross-compile your executable with <code>ocaml-solo5</code>, you need to define a new
build context in the <code>dune-workspace</code> file:</p>
<pre><code class="language-bash">$ cat &gt;dune-workspace&lt;&lt;EOF
(lang dune 3.0)
(context (default))
(context (default
 (name solo5)
 (host default)
 (toolchain solo5)
 (disable_dynamically_linked_foreign_archives true)))
EOF
</code></pre>
<p>Cross-compilation requires that the source code of your dependencies (in this
case, <code>mkernel</code>) is available locally. You can fetch it with <code>opam source</code>:</p>
<pre><code class="language-bash">$ mkdir vendors
$ opam source mkernel --dir vendors/mkernel
</code></pre>
<p>You can now create your unikernel:</p>
<pre><code class="language-bash">$ cat &gt;dune-project&lt;&lt;EOF
(lang dune 3.0)
EOF
$ cat &gt;main.ml&lt;&lt;EOF
let () = Mkernel.(run []) @@ fun () -&gt;
  print_endline "Hello World!"
EOF
$ dune build ./main.exe
</code></pre>
<p>Launching a unikernel is different from launching a regular executable, because
it runs as a virtual machine. You need to use a <em>tender</em> to start it. Here, we
use <code>solo5-hvt</code>:</p>
<pre><code class="language-bash">$ solo5-hvt -- _build/solo5/main.exe --solo5:quiet
Hello World!
</code></pre>
<p>Congratulations, you have just created your first unikernel! In the next
chapter, we will build a small echo server using <code>mnet</code> and set up networking
for your unikernel. Unikernels come with their own concepts and constraints
that are important to understand. The <code>mkernel</code> <a href="https://robur-coop.github.io/mkernel/local/mkernel/Mkernel/index.html">documentation</a>
covers these fundamentals in depth, explaining how Solo5 and OCaml fit
together.</p>
<h2 id="important-constraints"><a class="header" href="#important-constraints">Important constraints</a></h2>
<p>There are two essential things to keep in mind when building unikernels.</p>
<p>The first is that the <code>Unix</code> module is not available. The <code>ocaml-solo5</code>
compiler does not provide the <code>unix.cmxa</code> library. Since there is no underlying
operating system, system calls like <code>Unix.openfile</code> or <code>Unix.socket</code> simply do
not exist. This means that any library, including transitive dependencies, that
relies on the <code>Unix</code> module cannot be used in a unikernel. In practice, this is
why our ecosystem relies on pure OCaml reimplementations of protocols and
services (networking, DNS, TLS, and so on) rather than wrappers around C system
libraries.</p>
<p>The second is that dependencies must be vendored. Nearly all of your
dependencies need their source code present locally in a <code>vendors/</code> directory.
This is because cross-compilation with <code>ocaml-solo5</code> requires compiling C
stubs (if any) with the Solo5 toolchain, which is only possible when <code>dune</code>
has direct access to the source files. You can vendor a dependency with
<code>opam source</code>:</p>
<pre><code class="language-bash">$ opam source &lt;package&gt; --dir vendors/&lt;package&gt;
</code></pre>
<p>This must be done for every dependency that your unikernel uses, not just your
direct dependencies, but their transitive dependencies as well.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="echo-server"><a href="#echo-server" class="header">Echo server</a></h1>
<p><code>mnet</code> is a TCP/IP stack written entirely in OCaml, designed for unikernels.
Because the network stack is reimplemented in a memory-safe language, <code>mnet</code>
benefits from OCaml’s type system and from the broader ecosystem of formal
verification tools that can produce correct-by-construction OCaml code. This
means fewer classes of bugs (no buffer overflows, no use-after-free) and a
codebase that is easier to audit and reason about than a traditional C
implementation.</p>
<h2 id="a-note-on-performance"><a class="header" href="#a-note-on-performance">A note on performance</a></h2>
<p>Before going further, it is worth setting realistic expectations about
performance.</p>
<p>A pure OCaml TCP/IP stack will not match the raw throughput of an optimized
C implementation. The garbage collector introduces pause times, and OCaml’s
memory representation adds some overhead compared to bare pointers and manual
memory management.</p>
<p>However, the language is only part of the story. Regardless of whether a
unikernel is written in OCaml or C, it faces an inherent I/O disadvantage
compared to an application running directly on the host. A regular process on
Linux can make system calls that interact with the kernel’s network stack
directly. A unikernel cannot: it runs inside a sandboxed environment and must
go through two layers of indirection for every I/O operation. First, the
unikernel issues a hypercall to the tender (the host-side process that manages
the virtual machine). Then, the tender issues a system call to the host kernel,
which actually performs the I/O. This double indirection adds latency to every
network operation. There are techniques to reduce this cost (for example,
shared-memory ring buffers between the tender and the unikernel, similar to
what <code>virtio</code> provides), but the overhead can never be fully eliminated. This
is a fundamental constraint of the isolation model, not a limitation of any
particular implementation.</p>
<p>If your goal is to build the fastest possible web server, a unikernel is not
the right tool. But raw throughput is rarely the only metric that matters.
Unikernels excel in other dimensions: they have a minimal attack surface
because there is no shell, no unused drivers, and no package manager, only the
code your application needs. They boot in milliseconds because there is no
operating system to initialize, and their images are only a few megabytes
compared to hundreds for a typical container. The per-instance cost of running
a unikernel is therefore very low.</p>
<p>These properties naturally lead to a different way of thinking about services.
Rather than building a single monolithic application, you can decompose your
system into small, focused unikernels, where each one does one thing, boots
quickly, and consumes minimal resources. The deployment cost per component
becomes low enough that this architecture is practical, not just theoretical.</p>
<p>In short, do not expect a unikernel to outperform a native application in I/O.
Instead, think of unikernels as a way to build smaller, safer, and more
composable services.</p>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>The TCP/IP stack depends on a source of randomness (for generating TCP sequence
numbers, IPv6 addresses, and so on). We use <code>mirage-crypto</code> with its
<a href="https://en.wikipedia.org/wiki/Fortuna_(PRNG)">Fortuna</a> engine for this purpose. <code>mkernel</code> provides a mechanism to
declare the resources that a unikernel needs before it starts, including
devices (such as a network interface) and other values that require
initialization. To set up a working TCP/IP stack, we need three things: the
static IPv4 address to assign to the unikernel, an initialized random number
generator, and a network device (here named <code>"service"</code>).</p>
<pre><code class="language-ocaml">module RNG = Mirage_crypto_rng.Fortuna

let ( let@ ) finally fn = Fun.protect ~finally fn
let rng () = Mirage_crypto_rng_mkernel.initialize (module RNG)
let rng = Mkernel.map rng Mkernel.[]

let () =
  let ipv4 = Ipaddr.V4.Prefix.of_string_exn "10.0.0.2/24" in
  Mkernel.(run [ rng; Mnet.stack ~name:"service" ipv4 ])
  @@ fun rng (stack, _tcp, _udp) () -&gt;
  let@ () = fun () -&gt; Mirage_crypto_rng_mkernel.kill rng in
  let@ () = fun () -&gt; Mnet.kill stack in
  print_endline "Hello World!"
</code></pre>
<p>One important thing to notice in this code is the use of finalizers. Every
resource we create is paired with a cleanup function via the <code>let@</code> operator
(which is a shorthand for <code>Fun.protect ~finally</code>). This is not optional: Miou,
the scheduler used in our unikernels, requires that all resources be properly
released before the program exits. The random number generator, for instance,
spawns a background task that continuously feeds entropy to the Fortuna engine.
If that task is not terminated explicitly with
<code>Mirage_crypto_rng_mkernel.kill</code>, the scheduler will reject the program at
exit. The <a href="https://robur-coop.github.io/miou/retrospective.html#a-task-as-a-resource">Miou tutorial</a> covers this topic in more detail.</p>
<p>The same principle applies to <code>mnet</code>. Calling <code>Mnet.stack</code> starts several
background daemons (an Ethernet frame reader, an ARP responder, TCP timers, and
others) that run for the entire lifetime of the stack. <code>Mnet.kill</code> terminates
all of them. Forgetting to call it would leave dangling tasks, which Miou
treats as an error.</p>
<p>This cleanup pattern is not specific to unikernels: it applies to every
application built with Miou. Whenever you create a long-lived resource, you
should attach a finalizer to ensure it is released, even if an exception
interrupts the normal control flow.</p>
<h2 id="compilation"><a class="header" href="#compilation">Compilation</a></h2>
<p>As explained in the introduction, cross-compiling a unikernel with
<code>ocaml-solo5</code> requires that the source code of all dependencies (including
transitive ones) be available locally in a <code>vendors/</code> directory. Our echo
server depends on <code>mnet</code> and its own transitive dependencies, so we need to
vendor all of them. There is one point worth mentioning about <a href="https://github.com/xavierleroy/Zarith">Zarith</a>: it needs to be
compiled with <code>dune</code>. For several years, the Mirage team has maintained a fork
of Zarith that uses <code>dune</code>, available <a href="https://github.com/mirage/Zarith">here</a>. To make unikernel
compilation work, we need to <em>pin</em> this package. Here are the commands to
run:</p>
<pre><code class="language-bash">$ opam pin git+https://github.com/mirage/Zarith.git#zarith-1.14
$ opam source bstr --dir vendors/bstr
$ opam source mnet --dir vendors/mnet
$ opam source mirage-crypto-rng-mkernel --dir vendors/mirage-crypto-rng-mkernel
$ opam source gmp --dir vendors/gmp
$ opam source digestif --dir vendors/digestif
$ opam source kdf --dir vendors/kdf
$ opam source utcp --dir vendors/utcp
$ opam source zarith --dir vendors/zarith
</code></pre>
<p>Next, we update the <code>dune</code> file to declare the libraries our unikernel depends
on, the Solo5 ABI we are targeting, and the C stub for the device manifest:</p>
<pre><code class="language-dune">(executable
 (name main)
 (modules main)
 (link_flags :standard -cclib "-z solo5-abi=hvt")
 (libraries
  mkernel
  mirage-crypto-rng-mkernel
  mnet
  gmp)
 (foreign_stubs
  (language c)
  (names manifest)))
</code></pre>
<p>Finally, since our unikernel now uses a network device, we need to declare it
in <code>manifest.json</code>. The name <code>"service"</code> must match the <code>name</code> argument we
passed to <code>Mnet.stack</code> in the code above:</p>
<pre><code class="language-json">{"type":"solo5.manifest","version":1,"devices":[{"name":"service","type":"NET_BASIC"}]}
</code></pre>
<blockquote class="blockquote-tag blockquote-tag-tip">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p>
<p>To simplify the workflow around device manifests, you can <em>run</em> your unikernel
as a regular executable, and it will print the manifest it expects to stdout:</p>
<pre><code class="language-bash">$ dune exec ./main.exe &gt; manifest.json
</code></pre>
</blockquote>
<h2 id="network-configuration"><a class="header" href="#network-configuration">Network configuration</a></h2>
<p>Before we can run our unikernel, we need to set up a virtual network on the
host. This step is necessary because a unikernel does not share the host’s
network stack; it implements its own (that is the whole point of <code>mnet</code>). From
the unikernel’s perspective, it is a machine with its own Ethernet interface,
its own IP address, and its own TCP/IP stack. It needs to be connected to a
network just like a physical machine would be plugged into a switch.</p>
<p>On Linux, we can create this virtual network using two standard kernel
features: <a href="https://en.wikipedia.org/wiki/TUN/TAP">tap interfaces</a> and bridges (<code>bridge-utils</code>).</p>
<p>Think of a physical network in an office. Each computer has an Ethernet port
and a cable that connects it to a switch (a device whose only job is to forward
Ethernet frames between the machines plugged into it). Any machine on the
switch can talk to any other machine on the same switch, because the switch
delivers each frame to the right port based on the destination MAC address.
This forms what is called a local area network, or LAN.</p>
<p>We need to reproduce this setup virtually. A tap interface plays the role of
the Ethernet cable: it is a network device created by the Linux kernel that
behaves like a physical network card, except that no real hardware is involved.
When the tender (<code>solo5-hvt</code>) starts the unikernel, it attaches the unikernel’s
network device to a tap interface. From that point on, every Ethernet frame
that the unikernel sends appears on the tap interface, and every frame written
to the tap interface is delivered to the unikernel. A bridge plays the role of
the switch: it connects several network interfaces together and forwards
Ethernet frames between them. When we attach the tap interface to a bridge, the
unikernel becomes part of the local network formed by that bridge, just as
plugging a cable into a switch makes a computer part of the office LAN.</p>
<p>There is one more piece to the puzzle. A local network lets machines talk to
each other, but it does not, by itself, provide access to the outside world. In
our office analogy, the switch connects the computers to each other, but there
must be a router somewhere that connects the office LAN to the internet. That
router is what we call a gateway: it is the machine that knows how to forward
packets beyond the local network. When a machine wants to reach an IP address
that is not on its local network, it sends the packet to the gateway, and the
gateway takes care of routing it further.</p>
<p>In our setup, the host plays the role of the gateway. We assign an IPv4 address
to the bridge, which gives the host a presence on the unikernel’s local
network. The unikernel is then configured to use that address as its gateway.
When the unikernel wants to reach an address outside the local network (for
instance, a DNS server on the internet) it sends the packet to the host via the
bridge, and the host forwards it through its own network connection.</p>
<p>This is admittedly more system administration than development. The
configuration we describe here is simple and generic; your network topology may
require adjustments. But it is worth understanding what these pieces do,
because a unikernel sits at the intersection of application development and
deployment. Understanding both sides is part of what makes the unikernel
approach powerful.</p>
<p>Here is how to set this up on Linux:</p>
<pre><code class="language-bash">$ sudo ip link add br0 type bridge
$ sudo ip addr add 10.0.0.1/24 dev br0
$ sudo ip tuntap add tap0 mode tap
$ sudo ip link set tap0 master br0
$ sudo ip link set br0 up
$ sudo ip link set tap0 up
</code></pre>
<p>The first command creates a bridge named <code>br0</code>. The second assigns it the
address <code>10.0.0.1</code> on the <code>10.0.0.0/24</code> subnet (this is the address the
unikernel will use as its gateway). The third command creates a tap interface
named <code>tap0</code>. The fourth attaches it to the bridge, and the last two bring both
interfaces up.</p>
<h2 id="launching-our-unikernel"><a class="header" href="#launching-our-unikernel">Launching our unikernel</a></h2>
<p>Now that the network is in place, we can run our unikernel. The
<code>--net:service=tap0</code> flag tells the tender to connect the unikernel’s
<code>"service"</code> network device to the <code>tap0</code> interface we just created:</p>
<pre><code class="language-bash">$ solo5-hvt --net:service=tap0 -- ./_build/solo5/main.exe --solo5:quiet
Hello World!
</code></pre>
<p>The output looks the same as before: the unikernel prints its message and
exits. But behind the scenes, something new happened. <code>mnet</code> initialized its
TCP/IP stack and connected to the virtual network. We can observe this by
capturing traffic on the bridge with <code>tcpdump</code>:</p>
<pre><code class="language-bash">$ sudo tcpdump -i br0
listening on br0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
14:30:00.000000 ARP, Request who-has 10.0.0.2 tell 10.0.0.2, length 28
</code></pre>
<p>The ARP request you see is the unikernel announcing its presence on the local
network. It is asking <em>who has this IP address?</em> to verify that no other
machine is already using it. This is a standard part of the IPv4 initialization
process (known as Gratuitous ARP).</p>
<h2 id="implementing-the-echo-server"><a class="header" href="#implementing-the-echo-server">Implementing the echo server</a></h2>
<p>We can now turn our “Hello World” unikernel into an actual echo server. The
idea is straightforward: we listen on a TCP port, accept incoming connections,
and for each client, read whatever they send and write it back until they
disconnect.</p>
<p>If you have already followed the <a href="https://robur-coop.github.io/miou/echo.html">Miou tutorial</a>, the
concurrency pattern will look familiar. Each client connection is handled in its
own Miou task, and we use Miou’s <em>orphans</em> mechanism to keep track of these
tasks and collect their results as they complete.</p>
<pre><code class="language-ocaml">let handler flow =
  let finally = Mnet.TCP.close in
  let r = Miou.Ownership.create ~finally flow in
  Miou.Ownership.own r;
  let buf = Bytes.create 0x7ff in
  let rec go () =
    match Mnet.TCP.read flow buf with
    | 0 -&gt; Miou.Ownership.release r
    | len -&gt;
        let str = Bytes.sub_string buf 0 len in
        Mnet.TCP.write flow str;
        go () in
  go ()

let rec clean_up orphans =
  match Miou.care orphans with
  | Some None | None -&gt; ()
  | Some (Some prm) -&gt;
    match Miou.await prm with
    | Ok () -&gt; clean_up orphans
    | Error exn -&gt;
      Logs.err (fun m -&gt; m "Unexpected exception: %s" (Printexc.to_string exn))

let () =
  let ipv4 = Ipaddr.V4.Prefix.of_string_exn "10.0.0.2/24" in
  Mkernel.(run [ rng; Mnet.stack ~name:"service" ipv4 ])
  @@ fun rng (stack, tcp, _udp) () -&gt;
  let@ () = fun () -&gt; Mirage_crypto_rng_mkernel.kill rng in
  let@ () = fun () -&gt; Mnet.kill stack in
  let rec go orphans listen =
    clean_up orphans;
    let flow = Mnet.TCP.accept tcp listen in
    let _ = Miou.async ~orphans @@ fun () -&gt; handler flow in
    go orphans listen in
  go (Miou.orphans ()) (Mnet.TCP.listen tcp 9000)
</code></pre>
<p>The <code>handler</code> function is the per-client logic. It registers the TCP connection
(<code>flow</code>) with Miou’s ownership system so that the connection is automatically
closed if the task is cancelled or crashes. It then enters a loop where it
reads into a buffer, writes back what was received, and repeats. When the
client closes the connection, <code>read</code> returns <code>0</code> and the handler releases the
resource.</p>
<p>The <code>clean_up</code> function iterates over completed tasks in the <code>orphans</code> set.
This is how Miou lets you collect the results of concurrent tasks without
blocking the accept loop. If a handler raised an unexpected exception, we log
it here rather than letting it propagate silently.</p>
<p>The main entry point ties everything together. It initializes the stack (as we
saw earlier), then enters an accept loop where it waits for a new client with
<code>Mnet.TCP.accept</code>, spawns a handler task with <code>Miou.async</code>, and repeats. The
<code>Mnet.TCP.listen</code> call prepares port 9000 for incoming connections, much like
the <code>listen</code> system call in the Unix socket API.</p>
<p>You will notice that the <code>mnet</code> API intentionally mirrors the Unix socket API.
The <code>listen</code>, <code>accept</code>, <code>read</code>, <code>write</code>, and <code>close</code> functions all work the way
you would expect. This is a deliberate design choice: rather than inventing a
new abstraction, we keep the interface familiar so that the only new concepts
you need to learn are related to the unikernel model itself, not to the
networking API.</p>
<h2 id="testing-the-echo-server"><a class="header" href="#testing-the-echo-server">Testing the echo server</a></h2>
<p>We can now build, launch, and test the echo server. We start the unikernel in
the background, then connect to it with <code>nc</code> (netcat) from the host:</p>
<pre><code class="language-bash">$ solo5-hvt --net:service=tap0 -- ./_build/solo5/main.exe --solo5:quiet &amp;
$ UNIKERNEL=$!
$ nc -q0 10.0.0.2 9000
Hello World!
Hello World!
^D
$ kill $UNIKERNEL
solo5-hvt: Exiting on signal 15
</code></pre>
<p>We type “Hello World!” and the unikernel sends it right back. Pressing <code>Ctrl-D</code>
closes the connection. The <code>$!</code> variable captures the PID of the background
process so that we can stop the unikernel cleanly with <code>kill</code> when we are done.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>And with that, we have a working echo server running as a unikernel. As you
have seen, the process is fairly straightforward once you know the key steps:
vendor your dependencies, declare your devices, and configure the virtual
network on the host. The networking concepts (tap interfaces, bridges, and
gateways) may be unfamiliar if you come from a pure application development
background, but they quickly become second nature with a bit of practice.</p>
<p>Now that the foundations are in place, the fun really begins. In the next
chapter, we will build on what we have learned here and implement a web server.
Our <a href="https://robur.coop/">cooperative</a> provides implementations of several protocols (such as
<a href="https://github.com/mirleft/ocaml-tls">ocaml-tls</a> and <a href="https://github.com/mirage/ocaml-dns">ocaml-dns</a>) that you can use to build
a wide range of services. We hope you are as excited as we are to see what you
will build next.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="web-server"><a class="header" href="#web-server">Web server</a></h1>
<p>In the previous chapter, we built an echo server: a unikernel that accepts TCP
connections and sends back whatever it receives. Now we will take a bigger step
and implement an HTTP web server.</p>
<p>Between the raw Ethernet frames we started with and the HTTP protocol lies a
whole stack of intermediate layers (TCP, IP, TLS), each of which is interesting
in its own right. Later chapters may explore some of those layers. For now, we
jump straight to HTTP because it demonstrates something important: even though
a unikernel is a minimal, single-purpose system, it can host a fully featured
web service.</p>
<p>This chapter assumes you have already completed the <a href="#echo-server">echo server</a>
chapter. You should have a working build setup (<code>dune</code>, <code>dune-workspace</code>,
<code>manifest.json</code>) and a configured network (a tap interface <code>tap0</code> and a bridge
<code>br0</code>) on your host.</p>
<h2 id="vendoring-the-dependencies"><a class="header" href="#vendoring-the-dependencies">Vendoring the dependencies</a></h2>
<p>Building an HTTP server requires more libraries than a simple echo server. The
HTTP protocol is layered on top of several components: a parser, a serializer,
content-type handling, and a framework to tie them all together. We need to
vendor all of them into our project:</p>
<pre><code class="language-shell">$ opam source flux --dir vendors/flux
$ opam source h1 --dir vendors/h1
$ opam source httpcats --dir vendors/httpcats
$ opam source mhttp --dir vendors/mhttp
$ opam source multipart_form-miou --dir vendors/multipart_form-miou
$ opam source prettym --dir vendors/prettym
$ opam source tls --dir vendors/tls
$ opam source x509 --dir vendors/x509
$ opam source vifu --dir vendors/vifu
</code></pre>
<p>That is quite a few packages, so let us walk through what each one does.</p>
<ul>
<li>The library we will interact with most directly is <code>vifu</code>. It is a web
framework for OCaml 5 designed specifically for unikernels (the <em>u</em> in <code>vifu</code>
stands for <em>unikernel</em>). It provides routing, request handling, and response
building: everything we need to define HTTP endpoints. <code>vifu</code> is the unikernel
variant of <a href="https://github.com/robur-coop/vif">vif</a>, a web framework that <a href="https://robur.coop/">our cooperative</a> uses in
production for <a href="https://builds.robur.coop/">builds.robur.coop</a>. If you are familiar with web
frameworks such as Express (JavaScript) or Sinatra (Ruby), <code>vifu</code> fills the
same role. We also recommend <a href="https://robur-coop.github.io/vif/">this tutorial</a> on implementing a
chatroom with websockets using Vif.</li>
<li>Under the hood, <code>mhttp</code>, <code>h1</code>, and <code>httpcats</code> together implement the HTTP
protocol for unikernels. They handle parsing of incoming HTTP requests and
serialization of outgoing HTTP responses, so we do not have to deal with the
wire format ourselves.</li>
<li><code>flux</code> is a streaming library used internally by the HTTP stack to process
request and response bodies without buffering them entirely in memory. If you
are interested in handling streams with Miou, we have written a
<a href="https://robur-coop.github.io/flux/local/flux/flux.html">tutorial</a> on the subject.</li>
<li>For file uploads, <code>multipart_form-miou</code> handles <code>multipart/form-data</code>
parsing, which is the encoding that web browsers use when uploading files
through an HTML form.</li>
<li>Finally, <code>tls</code> and <code>x509</code> provide TLS encryption and X.509 certificate
handling. Even though our example uses plain HTTP (no encryption), <code>vifu</code>
depends on these libraries because it supports HTTPS out of the box.</li>
</ul>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>As with the echo server, these dependencies must be vendored because
cross-compilation with <code>ocaml-solo5</code> requires local access to all source
code. See the <a href="#introduction">introduction</a> for a reminder of why.</p>
</blockquote>
<h2 id="a-minimal-web-server"><a class="header" href="#a-minimal-web-server">A minimal web server</a></h2>
<p>The only change to the build configuration compared to the echo server is
adding <code>vifu</code> (and its dependency <code>gmp</code>) to the library list in the <code>dune</code>
file. The <code>dune-workspace</code>, <code>dune-project</code>, and <code>manifest.json</code> files remain
the same:</p>
<pre><code class="language-diff">- (libraries mkernel mirage-crypto-rng-mkernel mnet)
+ (libraries mkernel mirage-crypto-rng-mkernel mnet vifu gmp)
</code></pre>
<p>Here is the complete web server:</p>
<pre><code class="language-ocaml">module RNG = Mirage_crypto_rng.Fortuna

let ( let@ ) finally fn = Fun.protect ~finally fn
let rng () = Mirage_crypto_rng_mkernel.initialize (module RNG)
let rng = Mkernel.map rng Mkernel.[]

let index req _server () =
  let open Vifu.Response.Syntax in
  let* () = Vifu.Response.with_text req "Hello World!\n" in
  Vifu.Response.respond `OK

let () =
  let ipv4 = Ipaddr.V4.Prefix.of_string_exn "10.0.0.2/24" in
  Mkernel.(run [ rng; Mnet.stack ~name:"service" ipv4 ])
  @@ fun rng (stack, tcp, _udp) () -&gt;
  let@ () = fun () -&gt; Mirage_crypto_rng_mkernel.kill rng in
  let@ () = fun () -&gt; Mnet.kill stack in
  let cfg = Vifu.Config.v 80 in
  let routes =
    let open Vifu.Uri in
    let open Vifu.Route in
    [ get (rel /?? any) --&gt; index ] in
  Vifu.run ~cfg tcp routes ()
</code></pre>
<p>The first half is the same initialization and cleanup boilerplate from the echo
server. The new part is the <code>index</code> handler and the route table.</p>
<p>The <code>index</code> handler receives an HTTP request, sets the response body to
<code>"Hello World!\n"</code> using <code>with_text</code>, and responds with HTTP status 200
(<code>OK</code>). The <code>let*</code> syntax, provided by <code>Vifu.Response.Syntax</code>, sequences these
response-building operations.</p>
<p>The route table maps URL patterns to handlers. Here we define a single route.</p>
<ul>
<li>The <code>get</code> combinator matches HTTP GET requests.</li>
<li>The <code>rel</code> part starts a URL pattern relative to the root <code>/</code>.</li>
<li>Adding <code>/?? any</code> tells the route to accept any query string on that path.</li>
<li>Finally, <code>--&gt;</code> connects the pattern to the <code>index</code> handler.</li>
</ul>
<p>So this route matches <code>GET /</code> (with or without query parameters) and calls
<code>index</code>. The <a href="https://robur-coop.github.io/vif/my_first_vif_application.html#routes">vif tutorial</a> covers the routing DSL in more
detail, including how to capture path segments and query parameters.</p>
<p>The last two lines tie everything together. <code>Vifu.Config.v 80</code> configures the
server to listen on port 80. <code>Vifu.run</code> takes the TCP state from our network
stack and the route table, then starts serving HTTP requests. Unlike the echo
server, where we wrote the accept loop ourselves, <code>vifu</code> handles connection
management, HTTP parsing, and request dispatching for us.</p>
<h2 id="building-and-running"><a class="header" href="#building-and-running">Building and running</a></h2>
<p>The build and launch steps are identical to the echo server. If you have not
set up the network yet, the <a href="#echo-server">echo chapter</a> walks you through it.</p>
<pre><code class="language-shell">$ dune build ./main.exe
$ solo5-hvt --net:service=tap0 -- ./_build/solo5/main.exe --solo5:quiet &amp;
$ UNIKERNEL=$!
$ curl http://10.0.0.2/
Hello World!
$ kill $UNIKERNEL
solo5-hvt: Exiting on signal 15
</code></pre>
<p>With just a few lines of OCaml, we have a working HTTP server running as a
unikernel. You can also point a web browser at <code>http://10.0.0.2/</code> and see the
same result.</p>
<h2 id="crunch--zip"><a class="header" href="#crunch--zip">Crunch &amp; Zip!</a></h2>
<p>A plain-text “Hello World” is nice, but a real web service needs to serve HTML
pages, stylesheets, and other assets. To show what <code>vifu</code> can do, we are going
to build a small but practical service: a web page where users can upload files
and receive a zip archive in return. This raises two questions. First, how do
we serve static files (such as <code>index.html</code>) from a unikernel that has no file
system? And second, how do we receive uploaded files from the user and zip
them? Let us tackle the first question now.</p>
<h3 id="how-to-open-a-file"><a class="header" href="#how-to-open-a-file">How to open a file?</a></h3>
<p>A unikernel has access to a block device (essentially a raw disk), but there is
no file system built on top of it. We <em>could</em> implement one, but that would add
significant complexity for what is actually a simple need: serving files whose
content is known at build time and never changes at runtime.</p>
<p>Instead of reading files from disk, we can <em>embed</em> them directly into the
unikernel binary. The idea is straightforward: a tool reads our files at build
time and generates an OCaml module where each file’s content is available as a
plain value. That module is compiled and linked into the unikernel like any
other code. At runtime, serving a file is just reading an OCaml value. No I/O,
no file system, no overhead.</p>
<p>The tool for this job is <code>mcrunch</code>. You can install it with:</p>
<pre><code class="language-shell">$ opam install mcrunch
</code></pre>
<p>This is a great example of one of the most powerful advantages of the unikernel
approach: we get to rethink what our application truly needs instead of
carrying along assumptions from traditional operating systems. In a
conventional server, we would reach for a file system without a second thought.
But a file system is a remarkably complex piece of software: it handles
permissions, directories, concurrent writes, journaling, and much more. Do we
actually need all of that here? For our web service, the answer is clearly no.
Our HTML and CSS files are known at build time, they never change at runtime,
and we only need to read them. There is no need for write access, no need for a
directory hierarchy, and we are only dealing with a couple of small files.</p>
<p>Once we recognize this, we can choose a much simpler solution: embed the file
contents directly into our binary. This is what we mean by reifying the
building blocks of our application. Instead of pulling in a general-purpose
abstraction such as a file system, we pick the simplest tool that actually
solves our problem. The unikernel philosophy encourages this kind of thoughtful
minimalism, and <code>mcrunch</code> is a perfect example of it in practice.</p>
<p>Let us create a small upload page. Save the following as <code>index.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Upload&lt;/title&gt;
    &lt;link rel="stylesheet" href="style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h3&gt;File selection&lt;/h3&gt;
    &lt;form action="/upload" method="POST" enctype="multipart/form-data"&gt;
        &lt;div id="file-list"&gt;
            &lt;div class="file-group"&gt;
                &lt;input type="file" name="files[]" required&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="controls"&gt;
            &lt;button type="button" onclick="addFileField()"&gt;+ Add a field&lt;/button&gt;
        &lt;/div&gt;

        &lt;div class="submit-area"&gt;
            &lt;button type="submit" class="btn-submit"&gt;Start archiving&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
    &lt;script&gt;
        function addFileField() {
            const container = document.getElementById('file-list');
            const group = document.createElement('div');
            group.className = 'file-group';

            group.innerHTML = `
                &lt;input type="file" name="files[]" required&gt;
                &lt;button type="button" class="btn-remove" onclick="this.parentElement.remove()"&gt;Remove&lt;/button&gt;
            `;

            container.appendChild(group);
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>And the accompanying <code>style.css</code>:</p>
<pre><code class="language-css">body {
    font-family: ui-sans-serif, system-ui, sans-serif;
    color: #1a1a1a;
    margin: 40px;
    line-height: 1.5;
}

form { max-width: 500px; }

.file-group {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    gap: 12px;
}

input[type="file"] {
    font-size: 13px;
    border: 1px solid #ddd;
    padding: 4px;
    flex-grow: 1;
}

button {
    background: none;
    border: 1px solid #1a1a1a;
    color: #1a1a1a;
    padding: 4px 12px;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
}

button:hover {
    background: #1a1a1a;
    color: white;
}

.btn-remove {
    border-color: #ccc;
    color: #666;
}

.controls {
    margin-top: 20px;
    display: flex;
    gap: 10px;
    border-top: 1px solid #eee;
    padding-top: 20px;
}

.submit-area { margin-top: 10px; }
.btn-submit { background: #1a1a1a; color: white; width: 100%; padding: 8px; }
</code></pre>
<p>The page displays a form that lets users select one or more files and submit
them via a POST request to <code>/upload</code>. The JavaScript function <code>addFileField()</code>
adds extra file inputs dynamically so that users can upload multiple files at
once. We will implement the <code>/upload</code> handler later; for now, let us focus on
serving these two files.</p>
<p>Then, to embed <code>index.html</code> and <code>style.css</code> into the unikernel, we update the
<code>dune</code> file with two changes: we add the <code>documents</code> module to the executable,
and we add a rule that generates it at build time using <code>mcrunch</code>.</p>
<pre><code class="language-dune">(executable
 (name main)
 (modules main documents)
 (link_flags :standard -cclib "-z solo5-abi=hvt")
 (libraries mkernel mirage-crypto-rng-mkernel mnet vifu gmp)
 (foreign_stubs
  (language c)
  (names manifest)))

(rule
 (targets documents.ml)
 (deps index.html style.css)
 (action
  (run mcrunch --list --file index:index.html --file style:style.css -o documents.ml)))
</code></pre>
<p>The <code>mcrunch</code> command reads our two files and generates a <code>documents.ml</code> file
containing two OCaml values: <code>Documents.index</code> and <code>Documents.style</code>. Each
value holds the file’s content as a <code>string list</code>.</p>
<p>A couple of details are worth noting about this command. The
<code>--file index:index.html</code> syntax maps an OCaml value name (<code>index</code>) to a
source file on disk (<code>index.html</code>); the colon separates the two. The <code>--list</code>
flag tells <code>mcrunch</code> to produce <code>string list</code> values rather than an array. This
matters because it works naturally with the streaming API we will use next: the
content can be sent to the client incrementally, without first concatenating
everything into a single buffer.</p>
<p>Now we replace our plain-text handler <code>index</code> with two handlers that serve the
embedded files:</p>
<pre><code class="language-ocaml">let index req _server () =
  let open Vifu.Response.Syntax in
  let from = Flux.Source.list Documents.index in
  let* () = Vifu.Response.with_source req from in
  Vifu.Response.respond `OK

let style req _server () =
  let open Vifu.Response.Syntax in
  let from = Flux.Source.list Documents.style in
  let* () = Vifu.Response.with_source req from in
  Vifu.Response.respond `OK
</code></pre>
<p>Instead of <code>with_text</code> (which takes a plain string), we now use <code>with_source</code>,
which takes a <em>flux source</em> (a stream of data). <code>Flux.Source.list</code> creates a
source from the <code>string list</code> that <code>mcrunch</code> generated. The response body is
then sent to the client piece by piece, which is more memory-efficient than
building the entire response as a single string.</p>
<p>Finally, we add a route for the stylesheet:</p>
<pre><code class="language-ocaml">let routes =
  let open Vifu.Uri in
  let open Vifu.Route in
  [ get (rel /?? any) --&gt; index
  ; get (rel / "style.css" /?? any) --&gt; style ]
</code></pre>
<p>The first route matches <code>GET /</code> and serves the HTML page. The second route
matches <code>GET /style.css</code>. When the browser loads <code>index.html</code> and encounters
the <code>&lt;link rel="stylesheet" href="style.css"&gt;</code> tag, it makes a second request
for <code>/style.css</code>, which is handled by the <code>style</code> handler.</p>
<h3 id="zip-on-the-fly"><a class="header" href="#zip-on-the-fly">Zip on the fly</a></h3>
<p>Let us continue building our service by adding a handler for the <code>POST /upload</code>
endpoint. When a user submits the upload form, the browser sends the selected
files as a <code>multipart/form-data</code> request. Our handler will read those files,
pack them into a zip archive, and send the archive back as the response.</p>
<p>This is where we need to talk about memory. A unikernel has a fixed memory
budget (512 megabytes by default). That is far less than a typical server
application running on a machine with tens of gigabytes of RAM. If your
application tries to hold too much data in memory at once, it will not slow
down gracefully: it will crash with an <code>Out_of_memory</code> exception. This means
you need to think carefully about how your code consumes memory. In particular,
you want to avoid loading entire files into memory when you do not have to.</p>
<p>The solution here is streaming. Instead of reading all the uploaded files into
memory, building the zip archive in memory, and then sending it to the client,
we process the data incrementally: we read a piece of input, compress it, write
it to the output, and move on to the next piece. At no point does the full
content of any file need to exist in memory all at once.</p>
<p>The library that makes this possible is <code>flux</code>. It lets you describe data
transformations as pipelines of streams, where each stage produces and consumes
data in small chunks. If you want to understand streaming in more depth, the
<a href="https://robur-coop.github.io/flux/local/flux/flux.html">flux tutorial</a> covers the concepts in detail. On top of <code>flux</code>,
the <code>flux_zip</code> library knows how to produce zip archives from a stream of
files.</p>
<p>Here is the upload handler:</p>
<pre><code class="language-ocaml">let nsec_per_day = Int64.mul 86_400L 1_000_000_000L
let ps_per_ns = 1_000L

let now_d_ps () =
  let nsec = Mkernel.clock_wall () in
  let nsec = Int64.of_int nsec in
  let days = Int64.div nsec nsec_per_day in
  let rem_ns = Int64.rem nsec nsec_per_day in
  let rem_ps = Int64.mul rem_ns ps_per_ns in
  (Int64.to_int days, rem_ps)

let now () = Ptime.v (now_d_ps ())

let gen =
  let tmp = Bytes.create 8 in
  fun () -&gt;
    Mirage_crypto_rng.generate_into tmp 8;
    let bits = Bytes.get_int64_le tmp 0 in
    Fmt.str "%08Lx" bits

let into_queue q =
  let open Flux in
  let init = Fun.const q
  and push q x = Bqueue.put q x; q
  and full = Fun.const false
  and stop = Bqueue.close in
  Sink { init; push; full; stop }

let zip req _server _ =
  let open Vifu.Response.Syntax in
  match Vifu.Request.of_multipart_form req with
  | Error _ -&gt;
      let* () = Vifu.Response.with_text req "Invalid multipart/form-data request" in
      Vifu.Response.respond `Bad_request
  | Ok stream -&gt;
      let mtime = now () in
      let src = Flux.Source.with_task ~size:0x7ff @@ fun q -&gt;
        let fn (part, orig) =
          let filename = Vifu.Multipart_form.filename part in
          let filename = Option.value ~default:(gen ()) filename in
          let src = Flux.Source.with_task ~size:0x7ff @@ fun q -&gt;
            Flux.Stream.into (into_queue q) (Flux.Stream.from orig) in
          Flux_zip.of_filepath ~mtime filename src in
        let stream = Flux.Stream.map fn stream in
        Flux.Stream.into (into_queue q) stream in
      let stream = Flux.Stream.from src in
      let stream = Flux.Stream.via Flux_zip.zip stream in
      let* () = Vifu.Response.add ~field:"Content-Type" "application/zip" in
      let* () = Vifu.Response.with_stream req stream in
      Vifu.Response.respond `OK
</code></pre>
<p>The <code>zip</code> handler starts by asking <code>vifu</code> to parse the incoming request as
<code>multipart/form-data</code>. If the request is malformed, the handler responds with a
400 Bad Request error. If parsing succeeds, <code>vifu</code> gives us a stream of parts,
where each part represents one uploaded file.</p>
<p>The core of the handler builds a pipeline in several stages. The outer
<code>Flux.Source.with_task</code> creates a task that iterates over the uploaded parts.
For each part, it extracts the filename (or generates one with <code>gen</code> if the
browser did not provide one), then wraps the part’s content into a flux source
using an inner <code>Flux.Source.with_task</code>. That source is passed to
<code>Flux_zip.of_filepath</code>, which produces a zip entry: a value that <code>flux_zip</code>
knows how to turn into the bytes of a zip archive. All these entries are
collected into a single stream, which is then piped through <code>Flux_zip.zip</code> to
produce the final zip output. The handler sets the response’s <code>Content-Type</code> to
<code>application/zip</code> and sends the stream to the client with <code>with_stream</code>.</p>
<p>There is a subtle but important point here. When we write this code, nothing
actually happens yet. We are describing a transformation pipeline, not
executing it. The data only starts flowing when the client begins reading the
response. This is what makes the approach memory-efficient: the unikernel never
needs to hold the entire archive in memory. Each <code>Flux.Source.with_task</code>
creates a bounded queue (the <code>~size:0x7ff</code> parameter sets the upper bound), so
the amount of data in memory at any given moment is limited, regardless of how
large the uploaded files are. A user could upload a one-gigabyte file and the
unikernel would process it using only a few kilobytes of buffer space.</p>
<p>Finally, we need to add the new route to our route table:</p>
<pre><code class="language-ocaml">let routes =
  let open Vifu.Uri in
  let open Vifu.Route in
  [ get (rel /?? any) --&gt; index
  ; get (rel / "style.css" /?? any) --&gt; style
  ; post Vifu.Type.multipart_form (rel / "upload" /?? any) --&gt; zip ]
</code></pre>
<p>The <code>post</code> combinator matches HTTP POST requests, so this route handles
<code>POST /upload</code>, which is exactly what our HTML form submits to.</p>
<p>Build and launch the unikernel the same way as before. Open <code>http://10.0.0.2/</code>
in your browser, select a few files, click “Start archiving”, and your browser
will download a zip file containing the uploaded files. You can test it also
with <code>curl</code>:</p>
<pre><code class="language-shell">$ solo5-hvt --net:service=tap0 -- ./_build/solo5/main.exe --solo5:quiet &amp;
$ UNIKERNEL=$!
$ curl -F file=@foo.txt -X POST http://10.0.0.2/upload -o foo.zip
$ unzip foo.zip
Archive:  foo.zip
  inflating: foo.txt
$ kill $UNIKERNEL
solo5-hvt: Exiting on signal 15
</code></pre>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>We started this chapter with a three-line “Hello World” handler and ended with
a unikernel that accepts file uploads and produces zip archives on the fly.
Along the way, we saw how <code>vifu</code> provides a familiar web-framework experience
(handlers, routes, responses) even though there is no operating system
underneath, how <code>mcrunch</code> solves the static-file problem by embedding content
directly into the binary at build time, and how <code>flux</code> enables memory-efficient
streaming so that even a unikernel with a small memory budget can process large
files comfortably.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-5842b119.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
